# generated by datamodel-codegen:
#   filename:  api.json
#   timestamp: 2021-01-16T01:13:01+00:00

from __future__ import annotations

from enum import Enum
from typing import Any, Dict, List, Optional

from pydantic import BaseModel, Field


class SubNetworkIdentifier(BaseModel):
    network: str = Field(..., example='shard 1')
    metadata: Optional[Dict[str, Any]] = Field(
        None, example={'producer': '0x52bc44d5378309ee2abf1539bf71de1b7d7be3b5'}
    )


class BlockIdentifier(BaseModel):
    index: int = Field(
        ..., description='This is also known as the block height.', example=1123941
    )
    hash_: str = Field(
        ...,
        alias='hash',
        example='0x1f2cc6c5027d2f201a5453ad1119574d2aed23a392654742ac3c78783c071f85',
    )


class PartialBlockIdentifier(BaseModel):
    index: Optional[int] = Field(None, example=1123941)
    hash_: Optional[str] = Field(
        None,
        alias='hash',
        example='0x1f2cc6c5027d2f201a5453ad1119574d2aed23a392654742ac3c78783c071f85',
    )


class TransactionIdentifier(BaseModel):
    hash_: str = Field(
        ...,
        alias='hash',
        description='Any transactions that are attributable only to a block (ex: a block event) should use the hash of the block as the identifier.',
        example='0x2f23fd8cca835af21f3ac375bac601f97ead75f2e79143bdf71fe2c4be043e8f',
    )


class OperationIdentifier(BaseModel):
    index: int = Field(
        ...,
        description='The operation index is used to ensure each operation has a unique identifier within a transaction. This index is only relative to the transaction and NOT GLOBAL. The operations in each transaction should start from index 0. To clarify, there may not be any notion of an operation index in the blockchain being described.',
        example=5,
        ge=0.0,
    )
    network_index: Optional[int] = Field(
        None,
        description='Some blockchains specify an operation index that is essential for client use. For example, Bitcoin uses a network_index to identify which UTXO was used in a transaction. network_index should not be populated if there is no notion of an operation index in a blockchain (typically most account-based blockchains).',
        example=0,
        ge=0.0,
    )


class SubAccountIdentifier(BaseModel):
    address: str = Field(
        ...,
        description='The SubAccount address may be a cryptographic value or some other identifier (ex: bonded) that uniquely specifies a SubAccount.',
        example='0x6b175474e89094c44da98b954eedeac495271d0f',
    )
    metadata: Optional[Dict[str, Any]] = Field(
        None,
        description='If the SubAccount address is not sufficient to uniquely specify a SubAccount, any other identifying information can be stored here. It is important to note that two SubAccounts with identical addresses but differing metadata will not be considered equal by clients.',
    )


class Currency(BaseModel):
    symbol: str = Field(
        ..., description='Canonical symbol associated with a currency.', example='BTC'
    )
    decimals: int = Field(
        ...,
        description='Number of decimal places in the standard unit representation of the amount. For example, BTC has 8 decimals. Note that it is not possible to represent the value of some currency in atomic units that is not base 10.',
        example=8,
        ge=0.0,
    )
    metadata: Optional[Dict[str, Any]] = Field(
        None,
        description='Any additional information related to the currency itself. For example, it would be useful to populate this object with the contract address of an ERC-20 token.',
        example={'Issuer': 'Satoshi'},
    )


class SyncStatus(BaseModel):
    current_index: Optional[int] = Field(
        None,
        description='CurrentIndex is the index of the last synced block in the current stage. This is a separate field from current_block_identifier in NetworkStatusResponse because blocks with indices up to and including the current_index may not yet be queryable by the caller. To reiterate, all indices up to and including current_block_identifier in NetworkStatusResponse must be queryable via the /block endpoint (excluding indices less than oldest_block_identifier).',
        example=100,
    )
    target_index: Optional[int] = Field(
        None,
        description='TargetIndex is the index of the block that the implementation is attempting to sync to in the current stage.',
        example=150,
    )
    stage: Optional[str] = Field(
        None,
        description='Stage is the phase of the sync process.',
        example='header sync',
    )
    synced: Optional[bool] = Field(
        None,
        description='sycned is a boolean that indicates if an implementation has synced up to the most recent block. If this field is not populated, the caller should rely on a traditional tip timestamp comparison to determine if an implementation is synced. This field is particularly useful for quiescent blockchains (blocks only produced when there are pending transactions). In these blockchains, the most recent block could have a timestamp far behind the current time but the node could be healthy and at tip.',
    )


class Peer(BaseModel):
    peer_id: str = Field(..., example='0x52bc44d5378309ee2abf1539bf71de1b7d7be3b5')
    metadata: Optional[Dict[str, Any]] = None


class Version(BaseModel):
    rosetta_version: str = Field(
        ...,
        description='The rosetta_version is the version of the Rosetta interface the implementation adheres to. This can be useful for clients looking to reliably parse responses.',
        example='1.2.5',
    )
    node_version: str = Field(
        ...,
        description='The node_version is the canonical version of the node runtime. This can help clients manage deployments.',
        example='1.0.2',
    )
    middleware_version: Optional[str] = Field(
        None,
        description='When a middleware server is used to adhere to the Rosetta interface, it should return its version here. This can help clients manage deployments.',
        example='0.2.7',
    )
    metadata: Optional[Dict[str, Any]] = Field(
        None,
        description='Any other information that may be useful about versioning of dependent services should be returned here.',
    )


class OperationStatus(BaseModel):
    status: str = Field(
        ..., description='The status is the network-specific status of the operation.'
    )
    successful: bool = Field(
        ...,
        description='An Operation is considered successful if the Operation.Amount should affect the Operation.Account. Some blockchains (like Bitcoin) only include successful operations in blocks but other blockchains (like Ethereum) include unsuccessful operations that incur a fee. To reconcile the computed balance from the stream of Operations, it is critical to understand which Operation.Status indicate an Operation is successful and should affect an Account.',
    )


class Timestamp(BaseModel):
    __root__: int = Field(
        ...,
        description='The timestamp of the block in milliseconds since the Unix Epoch. The timestamp is stored in milliseconds because some blockchains produce blocks more often than once a second.',
        example=1582833600000,
        ge=0.0,
    )


class CurveType(Enum):
    secp256k1 = 'secp256k1'
    secp256r1 = 'secp256r1'
    edwards25519 = 'edwards25519'
    tweedle = 'tweedle'


class SignatureType(Enum):
    ecdsa = 'ecdsa'
    ecdsa_recovery = 'ecdsa_recovery'
    ed25519 = 'ed25519'
    schnorr_1 = 'schnorr_1'
    schnorr_poseidon = 'schnorr_poseidon'


class CoinAction(Enum):
    coin_created = 'coin_created'
    coin_spent = 'coin_spent'


class CoinIdentifier(BaseModel):
    identifier: str = Field(
        ...,
        description='Identifier should be populated with a globally unique identifier of a Coin. In Bitcoin, this identifier would be transaction_hash:index.',
        example='0x2f23fd8cca835af21f3ac375bac601f97ead75f2e79143bdf71fe2c4be043e8f:1',
    )


class CoinChange(BaseModel):
    coin_identifier: CoinIdentifier
    coin_action: CoinAction


class ExemptionType(Enum):
    greater_or_equal = 'greater_or_equal'
    less_or_equal = 'less_or_equal'
    dynamic = 'dynamic'


class BlockEventType(Enum):
    block_added = 'block_added'
    block_removed = 'block_removed'


class Operator(Enum):
    or_ = 'or'
    and_ = 'and'


class Direction(Enum):
    forward = 'forward'
    backward = 'backward'


class MempoolResponse(BaseModel):
    transaction_identifiers: List[TransactionIdentifier]


class MetadataRequest(BaseModel):
    metadata: Optional[Dict[str, Any]] = None


class NetworkStatusResponse(BaseModel):
    current_block_identifier: BlockIdentifier
    current_block_timestamp: Timestamp
    genesis_block_identifier: BlockIdentifier
    oldest_block_identifier: Optional[BlockIdentifier] = None
    sync_status: Optional[SyncStatus] = None
    peers: List[Peer]


class ConstructionCombineResponse(BaseModel):
    signed_transaction: str


class TransactionIdentifierResponse(BaseModel):
    transaction_identifier: TransactionIdentifier
    metadata: Optional[Dict[str, Any]] = None


class CallResponse(BaseModel):
    result: Dict[str, Any] = Field(
        ...,
        description='Result contains the result of the `/call` invocation. This result will not be inspected or interpreted by Rosetta tooling and is left to the caller to decode.',
        example={'count': 1000},
    )
    idempotent: bool = Field(
        ...,
        description='Idempotent indicates that if `/call` is invoked with the same CallRequest again, at any point in time, it will return the same CallResponse. Integrators may cache the CallResponse if this is set to true to avoid making unnecessary calls to the Rosetta implementation. For this reason, implementers should be very conservative about returning true here or they could cause issues for the caller.',
    )


class Error(BaseModel):
    code: int = Field(
        ...,
        description='Code is a network-specific error code. If desired, this code can be equivalent to an HTTP status code.',
        example=12,
        ge=0.0,
    )
    message: str = Field(
        ...,
        description='Message is a network-specific error message. The message MUST NOT change for a given code. In particular, this means that any contextual information should be included in the details field.',
        example='Invalid account format',
    )
    description: Optional[str] = Field(
        None,
        description='Description allows the implementer to optionally provide additional information about an error. In many cases, the content of this field will be a copy-and-paste from existing developer documentation. Description can ONLY be populated with generic information about a particular type of error. It MUST NOT be populated with information about a particular instantiation of an error (use `details` for this). Whereas the content of Error.Message should stay stable across releases, the content of Error.Description will likely change across releases (as implementers improve error documentation). For this reason, the content in this field is not part of any type assertion (unlike Error.Message).',
        example='This error is returned when the requested AccountIdentifier is improperly formatted.',
    )
    retriable: bool = Field(
        ...,
        description='An error is retriable if the same request may succeed if submitted again.',
    )
    details: Optional[Dict[str, Any]] = Field(
        None,
        description='Often times it is useful to return context specific to the request that caused the error (i.e. a sample of the stack trace or impacted account) in addition to the standard error message.',
        example={'address': '0x1dcc4de8dec75d7aab85b567b6', 'error': 'not base64'},
    )


class NetworkIdentifier(BaseModel):
    blockchain: str = Field(..., example='bitcoin')
    network: str = Field(
        ...,
        description='If a blockchain has a specific chain-id or network identifier, it should go in this field. It is up to the client to determine which network-specific identifier is mainnet or testnet.',
        example='mainnet',
    )
    sub_network_identifier: Optional[SubNetworkIdentifier] = None

    def dict(self, *args, **kwargs):
        # Setting the subnetwork identifier as null for Cardano will result in a 500 error.
        kwargs['exclude_none'] = True
        return super().dict(*args, **kwargs)


class AccountIdentifier(BaseModel):
    address: str = Field(
        ...,
        description='The address may be a cryptographic public key (or some encoding of it) or a provided username.',
        example='0x3a065000ab4183c6bf581dc1e55a605455fc6d61',
    )
    sub_account: Optional[SubAccountIdentifier] = None
    metadata: Optional[Dict[str, Any]] = Field(
        None,
        description='Blockchains that utilize a username model (where the address is not a derivative of a cryptographic public key) should specify the public key(s) owned by the address in metadata.',
    )


class Amount(BaseModel):
    value: str = Field(
        ...,
        description='Value of the transaction in atomic units represented as an arbitrary-sized signed integer. For example, 1 BTC would be represented by a value of 100000000.',
        example='1238089899992',
    )
    currency: Currency
    metadata: Optional[Dict[str, Any]] = None


class PublicKey(BaseModel):
    hex_bytes: str = Field(
        ...,
        description='Hex-encoded public key bytes in the format specified by the CurveType.',
    )
    curve_type: CurveType


class SigningPayload(BaseModel):
    address: Optional[str] = Field(
        None,
        description='[DEPRECATED by `account_identifier` in `v1.4.4`] The network-specific address of the account that should sign the payload.',
    )
    account_identifier: Optional[AccountIdentifier] = None
    hex_bytes: str
    signature_type: Optional[SignatureType] = None


class Signature(BaseModel):
    signing_payload: SigningPayload
    public_key: PublicKey
    signature_type: SignatureType
    hex_bytes: str


class Coin(BaseModel):
    coin_identifier: CoinIdentifier
    amount: Amount


class BalanceExemption(BaseModel):
    sub_account_address: Optional[str] = Field(
        None,
        description='SubAccountAddress is the SubAccountIdentifier.Address that the BalanceExemption applies to (regardless of the value of SubAccountIdentifier.Metadata).',
        example='staking',
    )
    currency: Optional[Currency] = None
    exemption_type: Optional[ExemptionType] = None


class BlockEvent(BaseModel):
    sequence: int = Field(
        ...,
        description='sequence is the unique identifier of a BlockEvent within the context of a NetworkIdentifier.',
        example=5,
        ge=0.0,
    )
    block_identifier: BlockIdentifier
    type_: BlockEventType = Field(..., alias='type')


class RelatedTransaction(BaseModel):
    network_identifier: Optional[NetworkIdentifier] = None
    transaction_identifier: TransactionIdentifier
    direction: Direction


class AccountBalanceRequest(BaseModel):
    network_identifier: NetworkIdentifier
    account_identifier: AccountIdentifier
    block_identifier: Optional[PartialBlockIdentifier] = None
    currencies: Optional[List[Currency]] = Field(
        None,
        description='In some cases, the caller may not want to retrieve all available balances for an AccountIdentifier. If the currencies field is populated, only balances for the specified currencies will be returned. If not populated, all available balances will be returned.',
    )


class AccountBalanceResponse(BaseModel):
    block_identifier: BlockIdentifier
    balances: List[Amount] = Field(
        ..., description='A single account may have a balance in multiple currencies.'
    )
    metadata: Optional[Dict[str, Any]] = Field(
        None,
        description='Account-based blockchains that utilize a nonce or sequence number should include that number in the metadata. This number could be unique to the identifier or global across the account address.',
        example={'sequence_number': 23},
    )


class AccountCoinsRequest(BaseModel):
    network_identifier: NetworkIdentifier
    account_identifier: AccountIdentifier
    include_mempool: bool = Field(
        ...,
        description="Include state from the mempool when looking up an account's unspent coins. Note, using this functionality breaks any guarantee of idempotency.",
    )
    currencies: Optional[List[Currency]] = Field(
        None,
        description='In some cases, the caller may not want to retrieve coins for all currencies for an AccountIdentifier. If the currencies field is populated, only coins for the specified currencies will be returned. If not populated, all unspent coins will be returned.',
    )


class AccountCoinsResponse(BaseModel):
    block_identifier: BlockIdentifier
    coins: List[Coin] = Field(
        ...,
        description="If a blockchain is UTXO-based, all unspent Coins owned by an account_identifier should be returned alongside the balance. It is highly recommended to populate this field so that users of the Rosetta API implementation don't need to maintain their own indexer to track their UTXOs.",
    )
    metadata: Optional[Dict[str, Any]] = Field(
        None,
        description='Account-based blockchains that utilize a nonce or sequence number should include that number in the metadata. This number could be unique to the identifier or global across the account address.',
        example={'sequence_number': 23},
    )


class BlockRequest(BaseModel):
    network_identifier: NetworkIdentifier
    block_identifier: PartialBlockIdentifier


class BlockTransactionRequest(BaseModel):
    network_identifier: NetworkIdentifier
    block_identifier: BlockIdentifier
    transaction_identifier: TransactionIdentifier


class MempoolTransactionRequest(BaseModel):
    network_identifier: NetworkIdentifier
    transaction_identifier: TransactionIdentifier


class NetworkListResponse(BaseModel):
    network_identifiers: List[NetworkIdentifier]


class NetworkRequest(BaseModel):
    network_identifier: NetworkIdentifier
    metadata: Optional[Dict[str, Any]] = None


class ConstructionMetadataRequest(BaseModel):
    network_identifier: NetworkIdentifier
    options: Optional[Dict[str, Any]] = Field(
        None,
        description='Some blockchains require different metadata for different types of transaction construction (ex: delegation versus a transfer). Instead of requiring a blockchain node to return all possible types of metadata for construction (which may require multiple node fetches), the client can populate an options object to limit the metadata returned to only the subset required.',
    )
    public_keys: Optional[List[PublicKey]] = None


class ConstructionMetadataResponse(BaseModel):
    metadata: Dict[str, Any] = Field(
        ...,
        example={
            'account_sequence': 23,
            'recent_block_hash': '0x52bc44d5378309ee2abf1539bf71de1b7d7be3b5',
        },
    )
    suggested_fee: Optional[List[Amount]] = None


class ConstructionDeriveRequest(BaseModel):
    network_identifier: NetworkIdentifier
    public_key: PublicKey
    metadata: Optional[Dict[str, Any]] = None


class ConstructionDeriveResponse(BaseModel):
    address: Optional[str] = Field(
        None,
        description='[DEPRECATED by `account_identifier` in `v1.4.4`] Address in network-specific format.',
    )
    account_identifier: Optional[AccountIdentifier] = None
    metadata: Optional[Dict[str, Any]] = None


class ConstructionPreprocessResponse(BaseModel):
    options: Optional[Dict[str, Any]] = Field(
        None,
        description='The options that will be sent directly to `/construction/metadata` by the caller.',
    )
    required_public_keys: Optional[List[AccountIdentifier]] = None


class ConstructionPayloadsResponse(BaseModel):
    unsigned_transaction: str
    payloads: List[SigningPayload]


class ConstructionCombineRequest(BaseModel):
    network_identifier: NetworkIdentifier
    unsigned_transaction: str
    signatures: List[Signature]


class ConstructionParseRequest(BaseModel):
    network_identifier: NetworkIdentifier
    signed: bool = Field(
        ...,
        description='Signed is a boolean indicating whether the transaction is signed.',
    )
    transaction: str = Field(
        ...,
        description='This must be either the unsigned transaction blob returned by `/construction/payloads` or the signed transaction blob returned by `/construction/combine`.',
    )


class ConstructionHashRequest(BaseModel):
    network_identifier: NetworkIdentifier
    signed_transaction: str


class ConstructionSubmitRequest(BaseModel):
    network_identifier: NetworkIdentifier
    signed_transaction: str


class CallRequest(BaseModel):
    network_identifier: NetworkIdentifier
    method: str = Field(
        ...,
        description='Method is some network-specific procedure call. This method could map to a network-specific RPC endpoint, a method in an SDK generated from a smart contract, or some hybrid of the two. The implementation must define all available methods in the Allow object. However, it is up to the caller to determine which parameters to provide when invoking `/call`.',
        example='eth_call',
    )
    parameters: Dict[str, Any] = Field(
        ...,
        description='Parameters is some network-specific argument for a method. It is up to the caller to determine which parameters to provide when invoking `/call`.',
        example={
            'block_number': 23,
            'address': '0x52bc44d5378309ee2abf1539bf71de1b7d7be3b5',
        },
    )


class EventsBlocksRequest(BaseModel):
    network_identifier: NetworkIdentifier
    offset: Optional[int] = Field(
        None,
        description='offset is the offset into the event stream to sync events from. If this field is not populated, we return the limit events backwards from tip. If this is set to 0, we start from the beginning.',
        example=5,
        ge=0.0,
    )
    limit: Optional[int] = Field(
        None,
        description='limit is the maximum number of events to fetch in one call. The implementation may return <= limit events.',
        example=5,
        ge=0.0,
    )


class EventsBlocksResponse(BaseModel):
    max_sequence: int = Field(
        ...,
        description='max_sequence is the maximum available sequence number to fetch.',
        example=5,
        ge=0.0,
    )
    events: List[BlockEvent] = Field(
        ...,
        description='events is an array of BlockEvents indicating the order to add and remove blocks to maintain a canonical view of blockchain state. Lightweight clients can use this event stream to update state without implementing their own block syncing logic.',
    )


class SearchTransactionsRequest(BaseModel):
    network_identifier: NetworkIdentifier
    operator: Optional[Operator] = None
    max_block: Optional[int] = Field(
        None,
        description='max_block is the largest block index to consider when searching for transactions. If this field is not populated, the current block is considered the max_block. If you do not specify a max_block, it is possible a newly synced block will interfere with paginated transaction queries (as the offset could become invalid with newly added rows).',
        example=5,
        ge=0.0,
    )
    offset: Optional[int] = Field(
        None,
        description='offset is the offset into the query result to start returning transactions. If any search conditions are changed, the query offset will change and you must restart your search iteration.',
        example=5,
        ge=0.0,
    )
    limit: Optional[int] = Field(
        None,
        description='limit is the maximum number of transactions to return in one call. The implementation may return <= limit transactions.',
        example=5,
        ge=0.0,
    )
    transaction_identifier: Optional[TransactionIdentifier] = None
    account_identifier: Optional[AccountIdentifier] = None
    coin_identifier: Optional[CoinIdentifier] = None
    currency: Optional[Currency] = None
    status: Optional[str] = Field(
        None,
        description='status is the network-specific operation type.',
        example='reverted',
    )
    type_: Optional[str] = Field(
        None,
        alias='type',
        description='type is the network-specific operation type.',
        example='transfer',
    )
    address: Optional[str] = Field(
        None,
        description='address is AccountIdentifier.Address. This is used to get all transactions related to an AccountIdentifier.Address, regardless of SubAccountIdentifier.',
        example='0x1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347',
    )
    success: Optional[bool] = Field(
        None,
        description='success is a synthetic condition populated by parsing network-specific operation statuses (using the mapping provided in `/network/options`).',
    )


class Operation(BaseModel):
    operation_identifier: OperationIdentifier
    related_operations: Optional[List[OperationIdentifier]] = Field(
        None,
        description='Restrict referenced related_operations to identifier indices < the current operation_identifier.index. This ensures there exists a clear DAG-structure of relations. Since operations are one-sided, one could imagine relating operations in a single transfer or linking operations in a call tree.',
        example=[{'index': 1}, {'index': 2}],
    )
    type_: str = Field(
        ...,
        alias='type',
        description='Type is the network-specific type of the operation. Ensure that any type that can be returned here is also specified in the NetworkOptionsResponse. This can be very useful to downstream consumers that parse all block data.',
        example='Transfer',
    )
    status: Optional[str] = Field(
        None,
        description='Status is the network-specific status of the operation. Status is not defined on the transaction object because blockchains with smart contracts may have transactions that partially apply (some operations are successful and some are not). Blockchains with atomic transactions (all operations succeed or all operations fail) will have the same status for each operation. On-chain operations (operations retrieved in the `/block` and `/block/transaction` endpoints) MUST have a populated status field (anything on-chain must have succeeded or failed). However, operations provided during transaction construction (often times called "intent" in the documentation) MUST NOT have a populated status field (operations yet to be included on-chain have not yet succeeded or failed).',
        example='Reverted',
    )
    account: Optional[AccountIdentifier] = None
    amount: Optional[Amount] = None
    coin_change: Optional[CoinChange] = None
    metadata: Optional[Dict[str, Any]] = Field(
        None,
        example={
            'asm': '304502201fd8abb11443f8b1b9a04e0495e0543d05611473a790c8939f089d073f90509a022100f4677825136605d732e2126d09a2d38c20c75946cd9fc239c0497e84c634e3dd01 03301a8259a12e35694cc22ebc45fee635f4993064190f6ce96e7fb19a03bb6be2',
            'hex': '48304502201fd8abb11443f8b1b9a04e0495e0543d05611473a790c8939f089d073f90509a022100f4677825136605d732e2126d09a2d38c20c75946cd9fc239c0497e84c634e3dd012103301a8259a12e35694cc22ebc45fee635f4993064190f6ce96e7fb19a03bb6be2',
        },
    )


class Allow(BaseModel):
    operation_statuses: List[OperationStatus] = Field(
        ...,
        description='All Operation.Status this implementation supports. Any status that is returned during parsing that is not listed here will cause client validation to error.',
    )
    operation_types: List[str] = Field(
        ...,
        description='All Operation.Type this implementation supports. Any type that is returned during parsing that is not listed here will cause client validation to error.',
    )
    errors: List[Error] = Field(
        ...,
        description='All Errors that this implementation could return. Any error that is returned during parsing that is not listed here will cause client validation to error.',
    )
    historical_balance_lookup: bool = Field(
        ...,
        description='Any Rosetta implementation that supports querying the balance of an account at any height in the past should set this to true.',
    )
    timestamp_start_index: Optional[int] = Field(
        None,
        description='If populated, `timestamp_start_index` indicates the first block index where block timestamps are considered valid (i.e. all blocks less than `timestamp_start_index` could have invalid timestamps). This is useful when the genesis block (or blocks) of a network have timestamp 0. If not populated, block timestamps are assumed to be valid for all available blocks.',
        ge=0.0,
    )
    call_methods: Optional[List[str]] = Field(
        None,
        description='All methods that are supported by the /call endpoint. Communicating which parameters should be provided to /call is the responsibility of the implementer (this is en lieu of defining an entire type system and requiring the implementer to define that in Allow).',
    )
    balance_exemptions: Optional[List[BalanceExemption]] = Field(
        None,
        description='BalanceExemptions is an array of BalanceExemption indicating which account balances could change without a corresponding Operation. BalanceExemptions should be used sparingly as they may introduce significant complexity for integrators that attempt to reconcile all account balance changes. If your implementation relies on any BalanceExemptions, you MUST implement historical balance lookup (the ability to query an account balance at any BlockIdentifier).',
    )
    mempool_coins: Optional[bool] = Field(
        None,
        description="Any Rosetta implementation that can update an AccountIdentifier's unspent coins based on the contents of the mempool should populate this field as true. If false, requests to `/account/coins` that set `include_mempool` as true will be automatically rejected.",
    )


class NetworkOptionsResponse(BaseModel):
    version: Version
    allow: Allow


class ConstructionPreprocessRequest(BaseModel):
    network_identifier: NetworkIdentifier
    operations: List[Operation]
    metadata: Optional[Dict[str, Any]] = None
    max_fee: Optional[List[Amount]] = None
    suggested_fee_multiplier: Optional[float] = Field(None, ge=0.0)


class ConstructionPayloadsRequest(BaseModel):
    network_identifier: NetworkIdentifier
    operations: List[Operation]
    metadata: Optional[Dict[str, Any]] = None
    public_keys: Optional[List[PublicKey]] = None


class ConstructionParseResponse(BaseModel):
    operations: List[Operation]
    signers: Optional[List[str]] = Field(
        None,
        description='[DEPRECATED by `account_identifier_signers` in `v1.4.4`] All signers (addresses) of a particular transaction. If the transaction is unsigned, it should be empty.',
    )
    account_identifier_signers: Optional[List[AccountIdentifier]] = None
    metadata: Optional[Dict[str, Any]] = None


class Transaction(BaseModel):
    transaction_identifier: TransactionIdentifier
    operations: List[Operation]
    related_transactions: Optional[List[RelatedTransaction]] = None
    metadata: Optional[Dict[str, Any]] = Field(
        None,
        description='Transactions that are related to other transactions (like a cross-shard transaction) should include the tranaction_identifier of these transactions in the metadata.',
        example={'size': 12378, 'lockTime': 1582272577},
    )


class BlockTransaction(BaseModel):
    block_identifier: BlockIdentifier
    transaction: Transaction


class BlockTransactionResponse(BaseModel):
    transaction: Transaction


class MempoolTransactionResponse(BaseModel):
    transaction: Transaction
    metadata: Optional[Dict[str, Any]] = Field(
        None, example={'descendant_fees': 123923, 'ancestor_count': 2}
    )


class SearchTransactionsResponse(BaseModel):
    transactions: List[BlockTransaction] = Field(
        ...,
        description='transactions is an array of BlockTransactions sorted by most recent BlockIdentifier (meaning that transactions in recent blocks appear first). If there are many transactions for a particular search, transactions may not contain all matching transactions. It is up to the caller to paginate these transactions using the max_block field.',
    )
    total_count: int = Field(
        ...,
        description='total_count is the number of results for a given search. Callers typically use this value to concurrently fetch results by offset or to display a virtual page number associated with results.',
        example=5,
        ge=0.0,
    )
    next_offset: Optional[int] = Field(
        None,
        description='next_offset is the next offset to use when paginating through transaction results. If this field is not populated, there are no more transactions to query.',
        example=5,
        ge=0.0,
    )


class Block(BaseModel):
    block_identifier: BlockIdentifier
    parent_block_identifier: BlockIdentifier
    timestamp: Timestamp
    transactions: List[Transaction]
    metadata: Optional[Dict[str, Any]] = Field(
        None,
        example={
            'transactions_root': '0x1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347',
            'difficulty': '123891724987128947',
        },
    )


class BlockResponse(BaseModel):
    block: Optional[Block] = None
    other_transactions: Optional[List[TransactionIdentifier]] = Field(
        None,
        description="Some blockchains may require additional transactions to be fetched that weren't returned in the block response (ex: block only returns transaction hashes). For blockchains with a lot of transactions in each block, this can be very useful as consumers can concurrently fetch all transactions returned.",
    )
